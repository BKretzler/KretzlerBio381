# ---------------------------------------------------------
# Lecture 16
# Control Structures 1
# 30 Mar 2021
# Bailey M Kretzler
# ---------------------------------------------------------

#---------------------------------------------------------#
#                      Review boolean operators                      
#---------------------------------------------------------#



5>3 #greater than
5<3 #less than
5>=3 #greater than or equal to
5<=3 #less than or equal to
5==3 #is exactly
5!=3 # does not equal


# compound statements use and (&) and or (|)

#&
FALSE & FALSE #two falses = false
FALSE & TRUE  #false
TRUE & TRUE #true

5>3 & 1!=2 #both true, yields true

5>3 & 1==2 #first true, second false, yields false

5<3 & 1 ==2 #both false, yields false

#|

FALSE | FALSE # = false
FALSE | TRUE # = TRUE
TRUE | TRUE # = TRUE

5>3 | 1!=2 #both true, yields true

5>3 | 1==2 #first true, second false, yields true

5<3 | 1 ==2 #both false, yields false


#boolean with vectors

1:5 > 3


a <- 1:10
b <- 10:1

a == b
a>4&b>4 # two trues, at the 5th and 6th position (5 and 6)

a>4 & b < 4

sum (a>4&b>4) #sums 1s (trues) and 0s (falses)


#long form that only evaluates the first element
  #does not return a vector

a<4 & b>4 #evaluates and returns t/f vector

a< 4 && b>4 # only does the first comparison

a <4 | b>4

a<4 || b>4

#xor for testing or in vetors
#works only for TRUE FALSE

a<- c(0,0,1)
b<- c(0,1,1)

xor(a,b)

#---------------------------------------------------------#
#                      set operations                     
#---------------------------------------------------------#

# boolean algebra on a set of atomic vectors (numeric, logical, character strings)

a<- 1:7
b<- 5:10

#union to get all elements

union(a,b) #tells us the complete set present (doesn't repeat in common)

#intersect to get common elements

intersect(a,b)

#setdiff to get distinct elements in first set

setdiff(a,b) # for a

setdiff(b,a) #for b

#setequal to get identical elements

setequal(a,b) #not common returns false

#to compare two objects

z<- matrix(1:12, nrow = 4, byrow = T)
z1 <- matrix(1:12, nrow = 4, byrow = F)

setequal(z,z1) # contain same elements

z == z1

identical(z,z1)
z1 <- z

identical (z,z1)


# %in%

d<-12

d %in% union(a,b)
#or 

is.element(d, union(a,b))

g <- 5

g %in% union(a,b)


c<- 2


c == 1| c == 2 | c ==3 

c %in% c(1,2,3)

# check for partial matching with vector comparisons

d<- c(10,12)

d %in% union(a,b)

d %in% a


#---------------------------------------------------------#
#                      if statement
#---------------------------------------------------------#
  #anatomy of an if statement

# if(condition) expression
    #if condition is false then code is not done

#if(condition) expression1 else expression2
    # if condition is true - expression 1
    #if condition is false - expression 2

#if(condition1) expression1 else
#if(condition2) expression2 else
#expression 3

#can also use curly brackets to specify multiple code lines

z <- signif(runif(1),digits = 2)
print(z)

if(z > 0.5) cat(z,"is a bigger than average number", "\n")

if(z > 0.8) cat(z, "is a large number", "\n") else
  if(z < 0.2) cat(z, "is a small number", "\n") else
    {cat(z,"is a number of typical size","\n")
    cat("z^2 = ", z^2, "\n") 
    }

# prefers just one boolean 
z<- 1:10

if(z>7) print(z)

if(z<7) print(z)


#instead use subsetting

print(z[z<7])


#---------------------------------------------------------#
#                      ifelse
#---------------------------------------------------------#

#ifelse(test,yes,no)
# test = object that can be coerced into a logical

tester <- runif(1000) #generate some random unifrom numbers
eggs<- ifelse(tester > 0.35,rpois(n = 1000, lambda = 10.2),0)
hist(eggs) #posison with mean around 10.2 + a number of zeros generated by parasitism and chance





